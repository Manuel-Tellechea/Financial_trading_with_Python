# -*- coding: utf-8 -*-
"""backtestingOOP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l60baBdeYGs5OixNeTaY2ZjSxRIEIsMY
"""

# !pip install yfinance

import yfinance as yf
import numpy as np
import pandas as pd
from scipy.stats import skew


class Backtest:

    def __init__(self, symbol: str, stop: float, capital: float, leverage: float, risk: float):

        self.symbol = symbol
        self.stop = stop
        self.capital = capital
        self.leverage = leverage
        self.risk = risk

    def download_data(self):
        data = yf.download(self.symbol)
        return data

    def long(self, data):

        # Data transformations
        df_open = data.Open.values
        df_close = data.Close.values
        df_high = data.High.values
        df_low = data.Low.values

        # Indicators

        # Trades
        buy_list = []
        buy_date = []
        sell_list = []
        sell_date = []
        trailing_stop = np.zeros(len(data))
        flag_long = False

        for i in range(0, len(data)):

            # Entry condition
            if df_open[i] > df_close[i] and df_high[i] > df_high[i - 1] and flag_long == False and i + 1 < len(data):
                buy_list.append(df_open[i + 1])
                buy_date.append(data.index[i + 1])
                stop_price = df_open[i + 1] * (1 - self.stop)
                buy_stop = data.index[i + 1]
                flag_long = True

            # Stop loss exit
            if flag_long and data.index[i] >= buy_stop and i + 1 < len(data):
                if df_open[i] > trailing_stop[i - 1]:
                    if df_low[i] <= trailing_stop[i - 1]:
                        sell_list.append(trailing_stop[i - 1])
                        sell_date.append(data.index[i])
                        flag_long = False
                    else:
                        pass
                else:
                    sell_list.append(df_open[i])
                    sell_date.append(data.index[i])
                    flag_long = False

            # if flag_long and data.Date[i] > buy_date_1 and df_close[i] > df_open[i] and i + days < len(data):
            #     sell_list.append(df_open[i + 1])
            #     sell_date.append(data.Date[i + 1])
            #     flag_long = False

            if flag_long:
                trailing = df_close[i] - (df_close[i] * self.stop)
                stop_loss_price = max(trailing, stop_price)
                trailing_stop[i] = stop_loss_price

        if len(buy_list) > len(sell_list) and len(buy_date) > len(sell_date):
            sell_date.append(str(buy_date[-1]))
            sell_list.append(float(np.float32(buy_list[-1:])))

        trades = pd.DataFrame()
        trades['buy_date'] = buy_date
        trades['buy_price'] = buy_list
        trades['sell_date'] = sell_date
        trades['sell_price'] = sell_list

        return trades

    def statistics(self, trades, data):

        # Returns
        trades['pct'] = ((trades.sell_price.values / trades.buy_price.values) - 1) * self.leverage
        trades['accum'] = (((trades.pct + 1).cumprod()) * self.capital)  # * (1 - (2 * fee))
        trades['ret%'] = ((trades.accum[-1:] / self.capital) - 1) * 100
        ret = float(trades['ret%'][-1:])
        trades['CAGR'] = ((trades.accum[-1:] / self.capital) ** (252 / len(data)) - 1) * 100
        cagr = float(trades.CAGR[-1:])

        # Profit factor
        trades['gains'] = np.where(trades.pct > 0, trades.pct, 0)
        trades['loses'] = np.where(trades.pct <= 0, trades.pct, 0)
        trades['profit'] = trades.gains.cumsum()
        trades['loss'] = trades.loses.cumsum()
        trades['PF'] = trades.profit[-1:] / abs(trades.loss[-1:])
        pf = float(trades.PF[-1:])

        # Number of trades
        trades['trade'] = 1
        trades['tot_trades'] = trades.trade.cumsum()
        tot_trades = int(trades.tot_trades[-1:])

        # Maximum Drawdown
        trades['roll'] = trades.accum.cummax()
        trades['trade_DD'] = ((trades.accum / trades.roll) - 1) * 100
        trades['max_DD'] = trades.trade_DD.min()
        max_dd = float(trades.max_DD[-1:])

        # Mar ratio
        trades['MAR'] = trades.CAGR / abs(trades.max_DD)
        mar = float(trades.MAR[-1:])

        # Hit ratio
        trades['pos_trade'] = np.where(trades.pct > 0, 1, 0)
        trades['neg_trade'] = np.where(trades.pct < 0, 1, 0)
        trades['pos_trades'] = trades.pos_trade.cumsum()
        trades['neg_trades'] = trades.neg_trade.cumsum()
        trades['hit_ratio'] = (trades.pos_trades[-1:] / trades.tot_trades[-1:]) * 100
        hit_ratio = float(round(trades.hit_ratio[-1:]))

        # Annualized volatility
        trades['stdev'] = trades.pct.std() * self.leverage * 100
        std = float(trades.stdev[-1:])

        # Other metrics
        m_crit = abs((1 - 1 * (self.risk + 1)) / (1 - 1 * (1 - (max_dd / 100))))
        start_date = trades.buy_date.iloc[0]
        end_date = trades.sell_date.iloc[-1]
        skewness = skew(trades.pct)

        # Summary
        print()
        print('-' * 25, "Strategy Statistics")
        print()
        print("Start date", '.' * 14, start_date)
        print("End date", '.' * 16, end_date)
        print("Percentage return", '.' * 7, ret)
        print("CAGR", '.' * 20, cagr)
        print("Returns volatility", '.' * 6, std)
        print("Trades returns skewness", '.', skewness)
        print("Profit Factor", '.' * 11, pf)
        print("The number of trades", '.' * 4, tot_trades)
        print("The maximum Drawdown", '.' * 4, abs(max_dd))
        print("MAR ratio (CAGR/MAXDD)", '.' * 2, mar)
        print("% positive trades:", '.' * 6, hit_ratio)
        print("M Criterion %:", '.' * 10, round(m_crit * 100))
        print('-' * 45)


back = Backtest('VT', 0.05, 10000, 1, 0.02)
df = back.download_data()
trade = back.long(df)
stats = back.statistics(trade, df)
stats
